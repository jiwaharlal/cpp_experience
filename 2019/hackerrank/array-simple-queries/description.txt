Array and simple queries

Task description:

Given are the array of numbers,
And a sequence of queries, Q = (D, B, E), where

D - direction, to begin or to end
B - begin of range
E - end of range
As a result of query processed, range of elements in [B, E) is moved to begin or end of
the array, depending on direction D.

After a sequence of queries processed, elements in array are reordered.

Return Value:
Abs value of difference between first and last elements of array should be returned.
Also, resulting array should be printed

Solution,
Approach 1:

std::list provides efficient operation to move range of elements: list.splice()
Complexity of this operation is O(1)
The issue is, finding target iterators has O(n) complexity.
Thus, complexity of this solution is
O(n^2)
This approach is very simple to implement, and it's performance scores 17.88 of 80 possible points.

Approach 2:

To trace the reordering resulting from queries, mapping of elements is applied
Mapping entity looks is

struct RangeInfo {
    int begin;          // begin position of range in resulting array
    int range_begin;    // begin position in source array
    int size;           // size of range described by this entry
};

Thus, the initial state of array would be described by a single entry
RangeInfo{0, 0, array.size()};
Array of 10 elements, with first 3 elements moved to the end
{RangeInfo{0, 3, 7}, RangeInfo{7, 0, 3}}

The resulting state of array might be reconstructed by sequentially filling the resulting array
by elements from inital array, based on data in RangeInfo entries.

remapping algo

1. find range info entry on which query begin falls
2. if range begin falls in a middle of RangeInfo, break it at query begin
3. find range info entry on which query end falls
4. if range end falls in a middle of RangeInfo, break it at query end
5. if direction is "move to end", goto <to end>. Otherwise we deal with "move to begin"

6. <to begin> for first rangeInfo entry to the entry on begin, rangeInfo.begin += (q.E - q.B)
7. for rangeInfo-s from q.B to q.E, rangeInfo.begin -= q.B
8. move rangeInfo-s in range [q.B, q.E) to the mapping begin

9. <to end> for rangeInfo-s from q.E to mapping end, rangeInfo.begin -= q.B
10. for rangeInfo-s from q.B to q.E rangeInfo.begin += (array.size() - q.E)
11. move rangeInfo-s in range [q.B, q.E) to the mapping end

After each remap step, mapping size increases by [0, 2], and subsequent operations become more
consuming. This can be solved by reconstructing actual state of the array and reducing mapping to
initial single entry, but this operation itself has O(n) complexity.
The balance is found at
mapping_size_limit = square_root(arr.size())

And complexity of this solution is
O(m * n^0.5)
where
n - size of array
m - number of queries

